# 简洁API迁移方案

## 调研结论

### 现状分析
- **纯Mock架构**：所有数据从Mock文件直接导入
- **无API封装**：没有HTTP请求层，直接操作Mock数据
- **完整数据**：Mock包含33个门店、200+技师的真实信息
- **类型完善**：有完整的TypeScript接口定义

### 核心问题
需要从 `import { mockStores } from '@/mock/data/stores'` 切换到真实API调用。

## 迁移方案：最小侵入式替换

### Step 1：创建API配置（1小时）

```typescript
// src/config/api.ts
export const API_CONFIG = {
  baseURL: process.env.TARO_APP_API || 'http://localhost:3001/api/v2',
  useMock: process.env.TARO_APP_USE_MOCK === 'true'
};
```

```json
// package.json - 添加环境变量
{
  "scripts": {
    "dev:weapp": "TARO_APP_USE_MOCK=true npm run build:weapp -- --watch",
    "dev:api": "TARO_APP_USE_MOCK=false TARO_APP_API=http://localhost:3001/api/v2 npm run build:weapp -- --watch"
  }
}
```

### Step 2：封装请求函数（30分钟）

```typescript
// src/utils/request.ts
import Taro from '@tarojs/taro';
import { API_CONFIG } from '@/config/api';

export async function request(url: string, options: any = {}) {
  const { data } = await Taro.request({
    url: `${API_CONFIG.baseURL}${url}`,
    method: options.method || 'GET',
    data: options.data,
    timeout: 10000
  });
  
  return data;
}

// 模拟延迟（保持与Mock一致的体验）
export const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
```

### Step 3：服务层切换（核心改动）

```typescript
// src/services/store.ts - 修改前
import { mockStores } from '@/mock/data/stores';

export async function getNearbyStores(latitude?: number, longitude?: number, page = 1, pageSize = 10) {
  await sleep(300);
  // 直接操作mockStores...
}

// src/services/store.ts - 修改后
import { mockStores } from '@/mock/data/stores';
import { request } from '@/utils/request';
import { API_CONFIG } from '@/config/api';

export async function getNearbyStores(latitude?: number, longitude?: number, page = 1, pageSize = 10) {
  if (API_CONFIG.useMock) {
    // 保留原有Mock逻辑
    await sleep(300);
    // 原Mock代码不变...
    return { list, total, page, pageSize, hasMore };
  }
  
  // 新增真实API调用
  try {
    const data = await request('/stores/nearby', {
      data: { latitude, longitude, page, pageSize }
    });
    
    // 数据格式已匹配，直接返回
    return data.data;
  } catch (error) {
    console.error('API调用失败，降级到Mock:', error);
    // 失败时降级到Mock
    return getNearbyStores(latitude, longitude, page, pageSize);
  }
}
```

### Step 4：环境切换使用

```bash
# 开发时使用Mock（默认）
npm run dev:weapp

# 对接真实API
npm run dev:api

# 临时切换到Mock（不重启）
# 修改 API_CONFIG.useMock = true
```

## 迁移计划

### Week 1：基础设施
- ✅ 创建API配置 
- ✅ 封装请求函数
- ✅ 环境变量支持

### Week 2：门店模块
- 🔄 `getNearbyStores` → 真实API
- 🔄 `getStoreDetail` → 真实API  
- 🔄 `searchStores` → 真实API

### Week 3：技师模块
- 🔄 `getRecommendedTherapists` → 真实API
- 🔄 `getTherapistDetail` → 真实API
- 🔄 `searchTherapists` → 真实API

### Week 4：预约模块（待后端实现）
- ⏳ 预约创建
- ⏳ 预约查询
- ⏳ 预约管理

## 优势

1. **零学习成本**：开发者无需了解复杂的配置系统
2. **快速切换**：一行配置切换数据源
3. **自动降级**：API失败自动使用Mock
4. **保持原有逻辑**：Mock代码完全保留
5. **渐进式迁移**：按模块逐个替换

## 风险控制

```typescript
// 添加错误监控
const apiMonitor = {
  success: 0,
  failure: 0,
  
  record(success: boolean) {
    if (success) this.success++;
    else this.failure++;
    
    // 失败率过高时自动切换到Mock
    if (this.failure / (this.success + this.failure) > 0.1) {
      console.warn('API失败率过高，建议切换到Mock模式');
    }
  }
};
```

这个方案的核心思想是：**最小改动，最大灵活性**。通过一个环境变量控制整个数据源，开发者可以随时在Mock和真实API之间切换。